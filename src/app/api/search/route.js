export const runtime = "nodejs";

import { NextResponse } from "next/server";
import * as cheerio from "cheerio";
import { storePrompt } from "../../../services/promptStorage";

const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY;
const SEARCH_ENGINE_ID = process.env.SEARCH_ENGINE_ID;
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

export function OPTIONS() {
  return NextResponse.json(
    {},
    {
      status: 200,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type",
      },
    }
  );
}

export async function GET(req) {
  const { searchParams } = new URL(req.url);
  const query = searchParams.get("q") || "chatgpt";

  const searchApiUrl = `https://www.googleapis.com/customsearch/v1?key=${GOOGLE_API_KEY}&cx=${SEARCH_ENGINE_ID}&q=${encodeURIComponent(
    query
  )}`;

  try {
    const searchResponse = await fetch(searchApiUrl);
    const searchData = await searchResponse.json();

    if (!searchData.items || !Array.isArray(searchData.items)) {
      throw new Error("No search results found.");
    }

    const items = searchData.items.slice(0, 3); // Limit to top 3 results

    const scrapedPages = await Promise.all(
      items.map(async (item) => {
        try {
          const response = await fetch(item.link, {
            headers: {
              "User-Agent":
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0 Safari/537.36",
            },
          });

          const html = await response.text();
          const $ = cheerio.load(html);

          const bodyText = $("body")
            .text()
            .replace(/\s+/g, " ")
            .trim()
            .slice(0, 1000); // Limit text size

          return { link: item.link, content: bodyText };
        } catch (error) {
          return { link: item.link, error: error.message };
        }
      })
    );

    const validScrapes = scrapedPages.filter(
      (result) => !result.error && result.content
    );

    if (validScrapes.length === 0) {
      return NextResponse.json(
        {
          question: query,
          answer:
            "Could not retrieve readable information from the web search.",
          sources: items.map((item) => item.link),
        },
        { headers: { "Access-Control-Allow-Origin": "*" } }
      );
    }

    const contextText = validScrapes
      .map((res) => `=== Source: ${res.link} ===\n${res.content}`)
      .join("\n\n");

    const geminiPrompt = `Using the information below from multiple sources, answer the following question concisely:\n\nQuestion: ${query}\n\nInformation:\n${contextText}`;

    const geminiRes = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          contents: [{ role: "user", parts: [{ text: geminiPrompt }] }],
        }),
      }
    );

    const geminiData = await geminiRes.json();

    if (!geminiData.candidates?.length) {
      throw new Error("Gemini did not return a response.");
    }

    const answer =
      geminiData.candidates[0]?.content?.parts?.[0]?.text ||
      "No answer generated by Gemini.";

    await storePrompt(user, query, "enhancement", "dgdgd");

    return NextResponse.json(
      {
        question: query,
        answer,
        sources: validScrapes.map((item) => item.link),
      },
      {
        headers: {
          "Access-Control-Allow-Origin": "*",
        },
      }
    );
  } catch (err) {
    return NextResponse.json(
      { error: err.message || "Unexpected error occurred." },
      {
        status: 500,
        headers: {
          "Access-Control-Allow-Origin": "*",
        },
      }
    );
  }
}
